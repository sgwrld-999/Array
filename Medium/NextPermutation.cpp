#include<bits/stdc++.h>
using namespace std;   
/*
Problem name : Next Permutation
Problem link : https://leetcode.com/problems/next-permutation/
Explanation :
Approach 1 : Brute Force 
    - Generate all permutations and find the next permutation
    - Time Complexity : O(n!)
Approach 2 : Single Pass Approach 
    - Find the first decreasing element from the end if not found then reverse the array and return 
    - Find the element just greater than the first decreasing element
    - Swap the two elements
    - Reverse the array from the index of the first decreasing element
    - Time Complexity : O(n)
Question : Why we are finding the break point?
Answer : The permuation is start in lexographical order so by the observation or note worthy point is 
that the permutation is in decreasing order from the end. And we if there is break point or an element 
then the next permutation will be generated by that position.
Example : 
Sad 
Say 
Sia

S is same in all the three words so we will move to the next letter
a is same in 1st and 2nd word but in 3rd a is in the last position.
So the break point of 3rd word is at i as why because i > a not i < a similar comcept is applied to the
in the permutation of the numbers.
Question : Why we are finding the element just greater than the first decreasing element?
Answer : Because after the element in the lexographical order the next element will be the just greater than the 
first decreasing element,.
NOTE : It can be done using STL function next_permutation(nums.begin(), nums.end())
*/
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int brkPt = -1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                brkPt = i;
                break;
            }
        }
        if (brkPt == -1) {
            reverse(nums.begin(), nums.end());
            return;
        }
        for (int i = nums.size() - 1; i >= 0; i--) {
            if (nums[i] > nums[brkPt]) {
                swap(nums[i], nums[brkPt]);
                break;
            }
        }
        reverse(nums.begin() + brkPt + 1, nums.end());
    }
};

int main(){
    vector<int> nums = {1,2,3};
    Solution s;
    s.nextPermutation(nums);
    for(auto i : nums){
        cout << i << " ";
    }
    cout << endl;
    return 0;
}